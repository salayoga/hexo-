---
title: 浏览器垃圾回收
date: 2020-12-23 08:36:09
tags: 前端
---



在了解垃圾回收机制之前需要先知道浏览器的内核：

内核分为渲染引擎和javascript引擎。

<!--more-->

| 浏览器  | 渲染引擎                                                     | Javascript 引擎          |
| ------- | ------------------------------------------------------------ | ------------------------ |
| Chrome  | Blink(13 年之前使用的是 Safari 的 Webkit, Blink 是谷歌与欧朋一起搞的) | V8                       |
| Safari  | Webkit                                                       | JavaScriptCore           |
| Firefox | Gecko                                                        | SpiderMonkey--OdinMonkey |
| IE      | Trident                                                      | Chakra                   |

浏览器页面渲染有这两部分和共同完后。

js本身是没有办法管理内存和垃圾回收，真正起作用的是js引擎。

#### 内存分配：

内存使用的时候分为栈和堆内存，栈容量小且连续，一般用于存储很小的临时变量，堆容量大不连续用于存储大型变量。

V8引擎的内存分配建立在弱分代假说：

绝大部分对象的生命周期很短,即存活时间很短。新生代

生命周期很长的对象基本是常驻对象。老生代

新生代：

**新生代**(32 位系统分配 16M 的内存空间，64 位系统翻倍 32M，不同浏览器可能不同，但是应该差不了多少)。

新生代对应存活时间很短的假说概念，这个空间的操作，非常频繁，绝大多数对象在这里经历一次生死轮回，基本消亡，没消亡的会晋升至老生代内。



新生代算法为 Scavenge 算法，典型牺牲空间换时间的败家玩意，怎么说呢？首先他将新生代分为两个相等的半空间( semispace ) **from space**  与 **to space**，来看看这个败家玩意，是怎么操作的，他使用宽度优先算法，是宽度优先，记住了不。两个空间，同一时间内，只会有一个空间在工作( from space )，另一个在休息( to space )。

1. 首先，V8 引擎中的垃圾回收器检测到 from space 空间快达到上限了，此时要进行一次垃圾回收了
2. 然后，从根部开始遍历，不可达对象(即无法遍历到的对象)将会**被标记**，并且复制**未被标记**的对象，放到 to space 中
3. 最后，清除 from space 中的数据，同时将 from space 置为空闲状态，即变成 to space，相应的 to space 变成 from space，俗称翻转

![图片](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/817b06be81fa4936b96e0df7395aa76b~tplv-k3u1fbpfcp-zoom-1.image)

也是，你说空间都给他了，他爱咋地处理就咋地处理呗，总不可能强迫王校长开二手奥拓吧，当然了，对于小对象，这么来一次，时间的优势那是杠杠的，虽然浪费了一半空间，但是问题不大，能 hold 住。

当然优秀的 V8 是不可能容忍，一个对象来回的在 form space 和 to space 中蹦跶的，当经历一次 form => to 翻转之后，发现某些未被标记的对象居然还在，会直接扔到老生代里面去，好似后浪参加比赛，晋级了，优秀的嘞。

除了上面一种情况，还有一个情况也会晋级，当一个对象，在被复制的时候，大于 to space 空间的 25% 的时候，也会晋级了，这种自带背景的选手，那是不敢动的，直接晋级到老生代。

**老生代**( 32 位操作系统分配大约 700M 内存空间，64 位翻倍 1.4G，一样，每个浏览器可能会有差异，但是差不了多少)。

老生代比起新生代可是要复杂的多，所谓能者多劳，空间大了，责任就大了，老生代可以分为以下几个区域：

- **old object space **即大家口中的老生代，不是全部老生代，这里的对象大部分是由新生代晋升而来
- **large object space **大对象存储区域，其他区域无法存储下的对象会被放在这里，基本是超过 1M 的对象，这种对象不会在新生代对象中分配，直接存放到这里，当然了，这么大的数据，复制成本很高，基本就是在这里等待命运的降临不可能接受仅仅是知其然，而不知其所以然
- **Map space **这个玩意，就是存储对象的映射关系的，其实就是隐藏类，啥是隐藏类？就不告诉你(不知道的大佬已经去百度了)
- **code space **简单点说，就是存放代码的地方，编译之后的代码，是根据大佬们写的代码编译出来的代码
  链接：https://juejin.cn/post/6909239354418266119


